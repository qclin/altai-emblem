// Title: Amoeba
// Author: FAL
// Date: 13. Nov. 2017
// Made with p5.js v0.5.16
// Generated by TypeScript v2.5.3

// Learned how to draw soft shapes from: "Ectoplasms" by Pierre MARZIN ( https://www.openprocessing.org/sketch/445834 )


"use strict";
//
// ------------ Math utility -----------------------------
//
/**
 * Returns the difference of two angles in range of -PI to PI.
 * @param angleA - the angle to subtract from
 * @param angleB - the angle to subtract
 */
function angleDifference(angleA, angleB) {
    let diff = (angleA - angleB) % (TWO_PI);
    if (diff < -PI)
        diff += TWO_PI;
    else if (diff > PI)
        diff -= TWO_PI;
    return diff;
}
//
// ------------ Amoeba -------------------------------------
//
/// <reference path="Common/MathUtility.ts" />
class Amoeba {
    constructor() {
        this.body = new PhysicsBody();
        this.body.position.set(random(width), random(height));
        {
            const directionAngle = Math.random() * TWO_PI;
            const speed = 100 * unitSpeed;
            this.body.velocity.set(speed * cos(directionAngle), speed * sin(directionAngle));
        }
        this.body.shapeSize = (20 + Math.random() * 50) * unitLength;
        this.counter = new FrameCounter();
        this.vertexCount = Math.floor(0.75 * this.body.shapeSize);
        this.noiseParameterOffset
            = createVector(Math.random(), Math.random(), Math.random()).mult(1024);
        this.noiseTime = 0;
    }
    static initializeStatic(shapeColor, area) {
        this.shapeColor = shapeColor;
        this.noiseTimeScale = 0.005;
        this.movableArea = area;
        this.maxSpeed = 200 * unitSpeed;
    }
    step() {
        this.move();
        this.body.step();
        Amoeba.movableArea.loopAtEnd(this.body);
        this.counter.increment();
        this.noiseTime += Amoeba.noiseTimeScale * (1 + 2 * this.body.getSpeed() / Amoeba.maxSpeed);
    }
    draw() {
        this.drawShape();
    }
    move() {
        const acc = 200 * unitSpeed / IDEAL_FRAME_RATE;
        this.body.accelerate(acc * random(-1, 1), acc * random(-1, 1));
    }
    drawShape() {
        const baseDistance = 0.5 * this.body.shapeSize;
        const noiseDistanceScale = baseDistance / (120 * unitLength);
        const noiseMagnitude = 3 * this.body.shapeSize;
        beginShape();
        for (let i = 0; i < this.vertexCount; i += 1) {
            const vertexAngle = (i / this.vertexCount) * TWO_PI;
            const cosine = cos(vertexAngle);
            const sine = sin(vertexAngle);
            const baseX = baseDistance * cosine;
            const baseY = baseDistance * sine;
            const noiseX = (2 * noise(this.noiseParameterOffset.x + noiseDistanceScale * (1 + cosine), this.noiseParameterOffset.y + noiseDistanceScale * (1 + sine), this.noiseParameterOffset.z + this.noiseTime) - 1) * noiseMagnitude;
            const noiseY = (2 * noise(this.noiseParameterOffset.x + noiseDistanceScale * (1 + cosine), this.noiseParameterOffset.y + noiseDistanceScale * (1 + sine), this.noiseParameterOffset.z + this.noiseTime + 1000) - 1) * noiseMagnitude;
            vertex(this.body.x + baseX + noiseX, this.body.y + baseY + noiseY);
        }
        endShape(CLOSE);
    }
}

// ------------ Kinematic quantity -----------------------------
//
class KinematicQuantity {
    constructor() {
        this.position = createVector();
        this.velocity = createVector();
    }
    step() {
        this.position.add(this.velocity);
    }
    bounce(normalUnitVector, restitution = 1) {
        this.velocity.add(p5.Vector.mult(normalUnitVector, (1 + restitution) * p5.Vector.dot(this.velocity, p5.Vector.mult(normalUnitVector, -1))));
    }
    getSpeed() {
        return this.velocity.mag();
    }
    getDirection() {
        return this.velocity.heading();
    }
    addSpeed(speedChange) {
        this.velocity.setMag(Math.max(0, this.velocity.mag() + speedChange));
    }
}
//
// ------------ Physics body -----------------------------
//
/// <reference path="KinematicQuantity.ts" />
/// <reference path="Steppable.ts" />
class PhysicsBody {
    constructor() {
        this.kinematicQuantity = new KinematicQuantity();
        this.shapeSize = 10;
        this.collisionRadius = 0.5 * this.shapeSize;
        this.hasFriction = false;
        this.decelerationFactor = 1;
    }
    get position() {
        return this.kinematicQuantity.position;
    }
    get x() {
        return this.kinematicQuantity.position.x;
    }
    get y() {
        return this.kinematicQuantity.position.y;
    }
    get velocity() {
        return this.kinematicQuantity.velocity;
    }
    get vx() {
        return this.kinematicQuantity.velocity.x;
    }
    get vy() {
        return this.kinematicQuantity.velocity.y;
    }
    getSpeed() {
        return this.kinematicQuantity.getSpeed();
    }
    getDirection() {
        return this.kinematicQuantity.getDirection();
    }
    setFriction(constant) {
        if (constant === 0) {
            this.hasFriction = false;
            return;
        }
        this.hasFriction = true;
        this.decelerationFactor = 1 - constant;
    }
    constrainSpeed(maxSpeed) {
        if (this.velocity.magSq() > sq(maxSpeed))
            this.velocity.setMag(maxSpeed);
    }
    step() {
        this.kinematicQuantity.step();
        if (this.hasFriction) {
            this.kinematicQuantity.velocity.mult(this.decelerationFactor);
        }
    }
    accelerate(x, y) {
        this.kinematicQuantity.velocity.add(x, y);
    }
    addSpeed(speedChange) {
        this.kinematicQuantity.addSpeed(speedChange);
    }
    collide(other) {
        return true;
    }
    attract(other, factor) {
        const relativePosition = createVector(other.position.x - this.position.x, other.position.y - this.position.y);
        const magnitude = factor / Math.min(1, relativePosition.magSq());
        const acceleration = relativePosition.normalize().mult(magnitude);
        this.velocity.add(acceleration);
        other.velocity.sub(acceleration);
    }
    attractToPoint(targetX, targetY, factor) {
        const relativePosition = createVector(targetX - this.position.x, targetY - this.position.y);
        const magnitude = factor / Math.min(1, relativePosition.magSq());
        const acceleration = relativePosition.normalize().mult(magnitude);
        this.velocity.add(acceleration);
    }
}
//
// ------------ Rectanble area -----------------------------
//
/// <reference path="PhysicsBody.ts" />
class RectangleArea {
    constructor(x1, y1, x2, y2) {
        this.leftPositionX = x1;
        this.topPositionY = y1;
        this.rightPositionX = x2;
        this.bottomPositionY = y2;
    }
    keepIn(body, restitution = 1) {
        const bodyRadius = 0.5 * body.shapeSize;
        if (body.x < this.leftPositionX + bodyRadius) {
            body.position.x = this.leftPositionX + bodyRadius;
            body.velocity.x = -restitution * body.velocity.x;
        }
        else if (body.x > this.rightPositionX - bodyRadius) {
            body.position.x = this.rightPositionX - bodyRadius;
            body.velocity.x = -restitution * body.velocity.x;
        }
        if (body.y < this.topPositionY + bodyRadius) {
            body.position.y = this.topPositionY + bodyRadius;
            body.velocity.y = -restitution * body.velocity.y;
        }
        else if (body.y > this.bottomPositionY - bodyRadius) {
            body.position.y = this.bottomPositionY - bodyRadius;
            body.velocity.y = -restitution * body.velocity.y;
        }
    }
    loopAtEnd(body) {
        if (body.x < this.leftPositionX) {
            body.position.x = this.rightPositionX;
        }
        else if (body.x > this.rightPositionX) {
            body.position.x = this.leftPositionX;
        }
        if (body.y < this.topPositionY) {
            body.position.y = this.bottomPositionY;
        }
        else if (body.y > this.bottomPositionY) {
            body.position.y = this.topPositionY;
        }
    }
}
//

/// <reference path="Amoeba.ts" />
/// <reference path="Common/Sprite.ts" />
/// <reference path="Common/RectangleArea.ts" />
/// <reference path="Common/ShapeColor.ts" />
/// <reference path="Common/FrameCounter.ts" />
//



function keyPressed() {
    if (keyCode === 80)
        noLoop(); // 80: 'P'
}
function keyReleased() {
    if (keyCode === 80)
        loop(); // 80: 'P'
}
